# Зачем нужны тесты
Тесты:
- выступают доказательством того, что код работает и работает как мы ожидаем;
- это статический анализ качества приложения;
- обеспечивают безопасность переработки кода;
- снижает процент дефектов;
- могут быть своего рода документацией, но только как дополнение.
# Виды тестирования
## Модульные тесты (unit)
Такие тесты тестируют отдельный модуль, например, функцию, компонент, класс.
## Интеграционные тесты
Такие тесты тестируют взаимодействие между модулями. Например, можно протестировать, что компонент вызывают функцию.
## Функциональные тесты (e2e)
 Такие тесты проверяют работу приложения в целом.
## Пирамида тестирования
Чем выше - тем дороже. Но пирамида может быть и перевернутой, т.е. порядок модульные - интеграционные - функциональные сохраняется, но количество тестов в каждой категории меняется.
Пирамида ниже актуальна для нового проекта, но в старых проектах чаще всего ситуаций "Мороженое", когда пирамида перевернута (рожок) и на вершине  - МТ (мороженое).
```
   --------------
  /Функциональные\
 / Интеграционные \
/     Модульные    \
--------------------
```
# Jest
## Основы Jest
### [Настройка Jest](https://jestjs.io/docs/getting-started)
Чтобы использовать синтаксис `ES Modules` нужно установить Babel.
### Структура модульного теста
В качестве примера структуры возьмём тестирование функции умножения.
```js
describe('multiply', () => {
	it('вернёт 36 при умножении 12 на 3', ()=> {
		expect(multiply(12,3)).toBe(36);
	})

	it('вернёт 0 при умножении любого числа на 0', () => {
		expect(multiply(12,0)).toBe(0);
		expect(multiply(3,0)).toBe(0);
	})
})
```
В реальных условиях тесты будут иметь несколько иную структуру. В тестировании применяется принцип `AAA`:
- Arrange - готовим данные;
- Act - выполняем действия;
- Assert - проверяем результат.
```js
describe('multiply', () => {
	it('вернёт 36 при умножении 12 на 3', ()=> {
		// Arrange
		const expectedResult = 36;
		// Act
		const actualResult = multiply(12,3);
		// Assert
		expect(actualResult).toBe(expectedResult);
	})
})
```
### [Варианты проверок](https://jestjs.io/docs/expect)
Описывать всё бессмысленно, лучше почитать документацию. Но приведу некоторые примеры.
- `toBe` используется для сравнения примитивов;
- `toEqual` используется для сравнения объектов;
### each
В Jest можно делать `it` с параметрами. Такой тест проверит сразу несколько кейсов.
```js
it.each(
	[
		{a: 4, b: 4, expected 8},
		{a: 2000, b: 404, expected: 2404}
	]
)('$a + $b = $expected', ({a, b, expected}) => {
	const result = a + b;
	expect(result).toBe(expected);
})
```
### [Jest Hooks](https://jestjs.io/docs/setup-teardown)
По сути, это всем знакомые `beforeEach`, `afterEach`, `beforeAll` и `afterAll`.
## Моки
Моки это:
- объекты, имитирующие реальные данные;
```js
export const tracklist = [
	{title: "Wesley's Theory", lenght: 4.47, artits: 'Kendrick Lamar', position: 1},
	{title: 'For Free?', lenght: 2.11, artits: 'Kendrick Lamar', position: 2},
	{title: 'King Kunta', lenght: 3.56, artits: 'Kendrick Lamar', position: 3},
	{title: 'Institutionalized', lenght: 4.32, artits: 'Kendrick Lamar', position: 4}
];
```
- поддельные функции, используются для тестирования количества вызова функции обратного вызова;
```js
const callback = jest.fn();
```
- шпионы, отслеживающие работу методов и подменяющие результат выполнения, если это нужно;
```js
const callbackSpyOn = jest.spyOn(someObject, 'nameOfMethod');
```
Стоит добавить, что моки нужно чистить в afterEach хуке с помощью `jest.clearAllMocks()`. Я бы это делал даже в случае такой записи `jest.spyOn(apiFun, 'getUserUUID').mockReturnValueOnce('Avalanches');`.
## [Тестирование ошибок](https://jestjs.io/docs/expect#tothrowerror)
Самое важное, что нужно знать о тестировании ошибок заключается всего в двух моментах:
- Просто `toThrow` тестирует ошибки в синхронном режиме;
- [`rejects.toThrow`](https://jestjs.io/docs/expect#rejects) тестирует ошибки в асинхронном режиме.
Еще можно тестировать ошибки через `try catch` блок.
## Проверка покрытия проекта
Включить проверку покрытия можно как в настройке `Jest`, так и через [`CLI`](https://jestjs.io/docs/cli#--coverageboolean).
Также в настройке можно указать директории, которые нужно тестировать, а какие требуется игнорировать (реализовано через `!`).
```js
collectCoverageFrom: [
	'<rootDir>/src/**/*.{js,jsx,ts,tsx}',
	'!**/node_modules/**',
	'!<rootDir>/src/**/*.mock.*'
],
```
Можно указать порог покрытия:
```js
coverageThreshold: {
	global: {
		branches: 80,
		functions: 80,
		lines: 80,
		statements: 80
	}
},
```
В данном случае `branches` - всевозможные ветвления кода (`if`, `else` и т.д.), `functions` говорит сама за себя, как и `lines`, `statements` же отвечает за покрытие для всех операторов в коде.
## [Debug режим для VSCode](https://github.com/microsoft/vscode-recipes/tree/main/debugging-jest-tests)
Может быть полезным.
## Разные `config` файлы
В проекте может быть несколько конфигурационных файлов. Так, можно разделять запуск модульных тестов и интеграционных, если требуется какая-то особая настройка для разных типов тестов.
Чтобы применялся тот или иной конфигурационный файл нужно указывать его в `npm` скрипте через `--config jest.optionalName.config.js`.
## Глобальная настройка
Бывает, что в тестировании проекта нам нужно указать какую-то глобальную переменную, которая задается в окружении. `Jest` не в курсе этой переменной, поэтому требуется глобальная настройка. Для этого используется `jest.setup.js` файл (название может быть другое) и поле `setupFiles` в конфигурации `Jest`. Если нужно настроить что-то после появления окружения, то используется `setupFilesAfterEnv`. В этих файлах можно добавлять переменные окружения `global.myVar`, писать функции и выполнять их и т.д. Простые глобальные переменные также можно добавить в конфигурационный файл через поле `globals`.
Через пакет `dotenv` (на каких-то версиях ноды работает и без этого пакета) можно в тестовом окружении использовать секретные переменные окружения, например, токены.
## Пользовательские функции проверки
В `Jest` можно писать свои пользовательские функции, которые будут сопоставлять ожидаемые данные с фактическими.

Синтаксис примерное такой:
```js
import {expect} from '@jest/globals'

const toBeGreaterThan = (actual, expected) => {
	// impl
};

expect.extend({toBeGreaterThan})
```
, где `actual` является значением в `expect`, а expected значением в `toBeGreater`:
```js
test('1996 больше 808', () => expect(1996).toBeGreaterThan(808));
```
Потом файл с функцией нужно добавить в `setupFilesAfterEnv`.
# TDD
В `Test Driven Development` сначала пишутся тесты, а потом реализация.
Выгоды дискуссионны, я выделил для себя такие:
- помогает до разработки прояснить как можно больше требований, чтобы в дальнейшем не пришлось многое переделывать, т.к. уже на этапе написания тестов продумываем реализацию
- высокое тестовое покрытие
	- проще рефакторить
	- проще добавлять новый функицонал
	- тесты как документация
